<!DOCTYPE html>
<html>
  <head>
  <link rel='shortcut icon' href='nature.ico' type='image/x-icon'/ >
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link type="text/css" rel="stylesheet" href="style.css"/>
	<script src="https://d3js.org/d3.v3.min.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-55956641-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>
  <body>
    <div id="body">
      
    </div>
    <script type="text/javascript">
var m = [20, 120, 20, 20],
    w = 1280 - m[1] - m[3],
    h = 500 - m[0] - m[2],
    i = 0,
    root;
var tree = d3.layout.tree()
    .size([h, w]);
var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });
var vis = d3.select("#body").append("svg:svg")
	.attr("class","svg2")
    .attr("width", w + m[1] + m[3])
    .attr("height", h + m[0] + m[2])
  .append("svg:g")
  .attr("transform", "translate(" + m[3] + "," + m[0] + ")");
d3.json("data.json", function(json) {
  root = json;
  root.x0 = h / 2;
  root.y0 = 0;
  function toggleAll(d) {
    if (d.children) {
      d.children.forEach(toggleAll);
      toggle(d);
    }
  }
  // Initialize the display to show a few nodes.
  // root.children.forEach(toggleAll);
  // toggle(root.children[1]);
  // toggle(root.children[1].children[2]);
  // toggle(root.children[9]);
  // toggle(root.children[9].children[0]);
  update(root);
});
function update(source) {
  var duration = d3.event && d3.event.altKey ? 5000 : 500;
  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse();
  // Normalize for fixed-depth.
  nodes.forEach(function(d) { d.y = d.depth * 180; });
  // Update the nodes…
  var node = vis.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });
	//  console.log(nodes);
  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("svg:g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .on("click", function(d) {
	  toggle(d);
	  update(d); 
	  })
	  .on("dblclick", function(d) {
	  if(!d.children) {
	  var child=d.eats;
	  var curveData=[];
	  var sourcenode={x:d.y+5,y:d.x};
	  
		nodes.forEach(function(d2) {
		if(child!=undefined) {
			for(var i=0;i<child.length;i++) {
				if(d2.name==child[i]){
					curveData[i] = {x:d2.y+5,  y:d2.x};
				}
			}
			}
		});
		
			for(var j=0;j<child.length;j++) {
			var edge = d3.select(".svg2").append('g');
			var diagonal2 = d3.svg.diagonal()
		.source(function() {return {"x":sourcenode.y, "y":sourcenode.x}; })            
		.target(function(d1) {
		return {"x":d1.y, "y":d1.x}; })
		.projection(function(d1) { return [d1.y, d1.x]; });
   
		d3.select(".svg2").select("g")
		.datum(curveData[j])
		.append("path")
      .attr("class", "relations")
      .attr("d", diagonal2)
      .attr("stroke", "#999")
        .attr("stroke-width", 1)
        .attr("fill", "none");
		}
	/*	
		function shapedEdge(d1,i) {
        var draw = d3.svg.line().interpolate("basis");
        var sw = linkScale(10);
        var midX = (d1.source.x + d1.target.x) / 2;
        var midY = d1.source.x - d1.target.x - sw;
        var midY2 = d1.source.x - d1.target.x + sw;
        return draw([[d1.source.x,0],[midX,midY],[d1.target.x + (sw*1.5),0],[d1.target.x - (sw*1.5),0],[midX,midY2],[d1.source.x,0]])
      }
	*/	
		}
	});
	  
	  
  nodeEnter.append("svg:circle")
      .attr("r", 1e-6)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });
  nodeEnter.append('a')
      .append("svg:text")
      .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
      .text(function(d) { return d.name; })
	  .attr("class","texts")
      .style('fill', function(d) {
        return d.free ? 'black' : '#999';
      })
      .style("fill-opacity", 1e-6);
  nodeEnter.append("svg:title")
    .text(function(d) {
      return d.description;
    })
	.attr("class","texts");
  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });
  nodeUpdate.select("circle")
      .attr("r", 6)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });
  nodeUpdate.select("text")
      .style("fill-opacity", 1);
  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .remove();
  nodeExit.select("circle")
      .attr("r", 1e-6);
  nodeExit.select("text")
      .style("fill-opacity", 1e-6);
  // Update the links…
  var link = vis.selectAll("path.link")
      .data(tree.links(nodes), function(d) { return d.target.id; });
  // Enter any new links at the parent's previous position.
  link.enter().insert("svg:path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      })
    .transition()
      .duration(duration)
      .attr("d", diagonal);
	  
		
		
		
  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", diagonal);
  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();
  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}
// Toggle children.
function toggle(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
}
    </script>
  </body>
</html>
